shiny::runApp()
runApp()
library(XML)
library(xml2)
runApp()
runApp()
runApp()
runApp()
library(xml2)
library(XML)
runApp()
runApp()
install.packages("xml2")
install.packages("xml2")
library(xml2)
shiny::runApp()
runApp()
runApp()
library(shiny)
library(tidyr)
library(httr)
library(RCurl)
library(XML)
library(bitops)
library(magrittr)
library(dplyr)
library(geosphere)
library(xml2)
library(rvest)
library(shiny)
library(tidyr)
library(httr)
library(RCurl)
library(XML)
library(bitops)
library(magrittr)
library(dplyr)
library(geosphere)
library(xml2)
library(rvest)
library(leaflet)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
load("D:/final_house_system/qr_result.RData")
load("D:/final_house_system/real.RData")
load("D:/final_house_system/result.RData")
load("D:/final_house_system/lr_result.RData")
runApp()
load("D:/PecuClass/final_project/result.RData")
output$showMap <- renderLeaflet({
showTableId = which(getData$tag %in% input$mapcheck) #%in% 陣列--選項是否在list裡
addresspoint<-address_output(input$address)
lng = getData[showTableId,2]
lat = getData[showTableId,3]
mylng=as.numeric(addresspoint$lng)
mylat=as.numeric(addresspoint$lat)
markers = leaflet() %>%   #生出leaflet
addTiles() %>%          #生出街道
setView(mylng,
mylat, zoom = input$Zoom) %>%  #決定地圖中心點
addMarkers( lng, lat, icon = Icons[input$mapcheck]) %>%
addMarkers( mylng, mylat)%>%
addCircles(lng = mylng,
lat = mylat,
weight = 1,
radius = input$radius
)
markers
#addresspoint<-address_output(input$address)
#setView(as.numeric(addresspoint$lng),as.numeric(addresspoint$lat),zoom=13)
})
runApp()
output$showMap <- renderLeaflet({
showTableId = which(getData$tag %in% input$mapcheck) #%in% 陣列--選項是否在list裡
addresspoint<-address_output(input$address)
lng = getData[showTableId,2]
lat = getData[showTableId,3]
mylng=as.numeric(addresspoint$lng)
mylat=as.numeric(addresspoint$lat)
markers = leaflet() %>%   #生出leaflet
addTiles() %>%          #生出街道
setView(mylng,
mylat, zoom = input$Zoom) %>%  #決定地圖中心點
addMarkers( lng, lat, icon = Icons[input$mapcheck]) %>%
addMarkers( mylng, mylat)%>%
addCircles(lng = mylng,
lat = mylat,
weight = 1,
radius = input$radius
)
markers
#addresspoint<-address_output(input$address)
#setView(as.numeric(addresspoint$lng),as.numeric(addresspoint$lat),zoom=13)
})
address_output<-function(x){
address_df <- data.frame(lat = 0,lng = 0,loc_type=NA)
root = "http://maps.google.com/maps/api/geocode/"
return.call = "xml"
sensor = "false"
# address_df<-c()
url_gen = paste0(root, return.call, "?address=",x, "&sensor=", sensor)
html_code<-read_xml(url_gen)
if(xml_text(xml_find_first(html_code,"//GeocodeResponse//status"))=="OK"){
lat=xml_find_first(html_code,"//result//geometry//location//lat")%>%xml_text()
lng=xml_find_first(html_code,"//result//geometry//location//lng")%>%xml_text()
loc_type=xml_find_first(html_code,"//result//geometry//location_type")%>%xml_text()
address_df[1,1] <- lat
address_df[1,2] <- lng
address_df[1,3] <- loc_type
}else if(xml_text(xml_find_first(html_code,"//GeocodeResponse//status"))=="ZERO_RESULTS"){
lat= ""
lng= ""
loc_type=""
address_df[1] <- lat
address_df[2] <- lng
address_df[3] <- loc_type
}
print(address_df)
}
lr_result_coefficient = read.table("lr_result_coefficient.csv",header = T,sep = ",",fileEncoding = "UTF-8")
# write.table(regression_x,file = "regression_x.csv",sep = ",",row.names =T,col.names = TRUE,fileEncoding = "UTF-8")
# qr_result_coefficient = read.table("qr_result_coefficient.csv",header = T,sep = ",",fileEncoding = "UTF-8")
regression_x = read.table("regression_x.csv",header = T,sep = ",",fileEncoding = "UTF-8")
qr_result_coefficient1<-read.table("qr_result_coefficient1.csv",header = T,sep = ",",fileEncoding = "UTF-8")
lr_result_coefficient1<-read.table("lr_result_coefficient1.csv",header = T,sep = ",",fileEncoding = "UTF-8")
qr_result_coefficient1<-as.matrix(qr_result_coefficient1)
lr_result_coefficient1<-as.matrix(lr_result_coefficient1)
# load("lr_result.RData")
# load("qr_result.RData")
regression_x_model<-cbind(1,regression_x)
regression_output <- function(x){
predict_mean <- c(1, x) %*% lr_result_coefficient1
predict_quantile <- c(1,x) %*% qr_result_coefficient1
temp <- density(predict_quantile)
dis_data  <- data.frame(x = temp$x, y = temp$y)
sample_sd <- sd(dis_data$x)
plott <- qplot(x,y,data=dis_data,geom="line")+
geom_ribbon(data=subset(dis_data,x>0 & x<quantile(dis_data$x,0.2)),aes(ymax=y),ymin=0,
fill="#CCFFFF",colour=NA,alpha=0.5) +
geom_ribbon(data=subset(dis_data,x>quantile(dis_data$x,0.2) & x<quantile(dis_data$x,0.3)),aes(ymax=y),ymin=0,
fill="#99CCCC",colour=NA,alpha=0.5) +
geom_ribbon(data=subset(dis_data,x>quantile(dis_data$x,0.3) & x<quantile(dis_data$x,0.4)),aes(ymax=y),ymin=0,
fill="#669999",colour=NA,alpha=0.5) +
geom_ribbon(data=subset(dis_data,x>quantile(dis_data$x,0.4) & x<quantile(dis_data$x,0.6)),aes(ymax=y),ymin=0,
fill="#336666",colour=NA,alpha=0.5) +
geom_ribbon(data=subset(dis_data,x>quantile(dis_data$x,0.6) & x<quantile(dis_data$x,0.7)),aes(ymax=y),ymin=0,
fill="#669999",colour=NA,alpha=0.5) +
geom_ribbon(data=subset(dis_data,x>quantile(dis_data$x,0.7) & x<quantile(dis_data$x,0.8)),aes(ymax=y),ymin=0,
fill="#99CCCC",colour=NA,alpha=0.5) +
geom_ribbon(data=subset(dis_data, x>quantile(dis_data$x,0.8) & x<quantile(dis_data$x,1)),aes(ymax=y),ymin=0,
fill="#CCFFFF",colour=NA,alpha=0.5)
# return(list(mean = predict_mean, sd = sample_sd, quantile = predict_quantile ,plot = plott))
return(plott)
}
distance_output<-function(x){
address_df <- data.frame(lat = 0,lng = 0,loc_type=NA)
root = "http://maps.google.com/maps/api/geocode/"
return.call = "xml"
sensor = "false"
# address_df<-c()
url_gen = paste0(root, return.call, "?address=",x, "&sensor=", sensor)
html_code<-read_xml(url_gen)
if(xml_text(xml_find_first(html_code,"//GeocodeResponse//status"))=="OK"){
lat=xml_find_first(html_code,"//result//geometry//location//lat")%>%xml_text()
lng=xml_find_first(html_code,"//result//geometry//location//lng")%>%xml_text()
loc_type=xml_find_first(html_code,"//result//geometry//location_type")%>%xml_text()
address_df[1,1] <- lat
address_df[1,2] <- lng
address_df[1,3] <- loc_type
}else if(xml_text(xml_find_first(html_code,"//GeocodeResponse//status"))=="ZERO_RESULTS"){
lat= ""
lng= ""
loc_type=""
address_df[1] <- lat
address_df[2] <- lng
address_df[3] <- loc_type
}
# ===================算距離=============================
station_location<-read.table("station_location.csv",header = T,sep = ",",fileEncoding = "UTF-8",stringsAsFactors = F)
park<-read.table("park.csv",header = T,sep = ",",fileEncoding = "UTF-8",stringsAsFactors = F)
park_location <- park[,c(1,6,7)]
address_df$lat <- as.numeric(address_df$lat)
address_df$lng <- as.numeric(address_df$lng)
park_location$ParkName<-as.character(park_location$ParkName)
park_location$Latitude <- as.numeric(park_location$Latitude)
park_location$Longitude <- as.numeric(park_location$Longitude)
distance_of_station <- data.frame(min_station = rep(0,dim(address_df)[1]),
min_station_name = rep(0,dim(address_df)[1]),
min_park = rep(0,dim(address_df)[1]),
min_park_name = rep(0,dim(address_df)[1]))
for(i in 1:length(address_df$lat)){ ######你把起點跟終點改一下，可以繼續往下算最短距離。
if(is.na(address_df[i,1]) == T) next
temp <- rep(0,dim(station_location)[1])
for(j in 1:dim(station_location)[1]){
temp[j] <- distCosine(address_df[i,c(2,1)] , station_location[j,c(4,3)])
}
distance_of_station[i,1] <- min(temp)
################################################################################################
######### 超重要！這邊多寫一個邏輯判斷式，是因為相同最膽距離下，可能會同時存在兩個捷運站，
######### 例如，給定最短距離是500公尺，剛好第一筆資料跟忠孝復興捷運站跟中山國中站的距離都是500
######### 所以這這種情況下，我先把最短捷運站名稱定義成NA，之後再想辦法處理。刪除NA資料時，要避開
######### 此欄位，因為此欄位還是存在最短距離的自變數
################################################################################################
if(length(station_location[ temp == min(temp) ,2]) > 1){
distance_of_station[i,2] <-NA
}else{
distance_of_station[i,2] <- station_location[ temp == min(temp) ,2]
}
################################################################################################
temp <- rep(0,dim(park_location)[1])
for(j in 1:dim(park_location)[1]){
temp[j] <- distCosine(address_df[i,c(2,1)] , park_location[j,c(3,2)])
}
distance_of_station[i,3] <- min(temp)
###################################################################################################
#跟前面同理   #####################################################################################
if(length(park_location[ temp == min(temp) ,1]) > 1){
distance_of_station[i,4] <-NA
}else{
distance_of_station[i,4] <- park_location[ temp == min(temp) ,1]}
################################################################################################
}
# return(list(min_station=distance_of_station$min_station,min_park=distance_of_station$min_park))
return(distance_of_station)
}
runApp()
source('D:/final_house_system/source_map_icon.R')
source('D:/final_house_system/addressfunction.R', encoding = 'UTF-8')
source('D:/final_house_system/source.R')
source('D:/final_house_system/distancevariable.R', encoding = 'UTF-8')
source('D:/final_house_system/shinylatlngdistance.R', encoding = 'UTF-8')
shinyServer(function(input, output) {
source("source.R")
output$rentprice <- renderText({
x = regression_x_model[1,]
x[,3:21]=0
x[,24:79]=0
x["area"] = input$area
area2 = input$area^2
x["area_square"] = area2
if (input$section != "d20") {
x[input$section] = 1
x[paste0("area", input$section)]= input$area
x[paste0("area2", input$section)]= area2
}
if (input$kind != "d40") {
x[input$kind] = 1
}
if (!is.null(input$top)) {x[input$top] = 1}
if (input$kind != "d40"&input$section != "d20") {
x[paste0(input$kind,input$section)] = 1
}
source("distancevariable.R")
distance<-distance_output(input$address)
x["min_station"]<-distance$min_station
x["min_park"]<-distance$min_park
print(distance$min_station)
x=as.matrix(x)
b=lr_result_coefficient[,2]
b=as.matrix(b)
y_hat=round(x%*%b,2)
paste0("Predicted Average price：",y_hat)
})
output$quantile <-  renderTable({
x = regression_x[1,]
x[,2:20]=0
x[,23:78]=0
x["area"] = input$area
area2 = input$area^2
x["area_square"] = area2
if (input$section != "d20") {
x[input$section] = 1
x[paste0("area", input$section)]= input$area
x[paste0("area2", input$section)]= area2
}
if (input$kind != "d40") {
x[input$kind] = 1
}
if (!is.null(input$top)) {x[input$top] = 1}
if (input$kind != "d40"&input$section != "d20") {
x[paste0(input$kind,input$section)] = 1
}
source("distancevariable.R")
distance<-distance_output(input$address)
x["min_station"]<-distance$min_station
x["min_park"]<-distance$min_park
x=as.matrix(x)
predict_quantile <- c(1,x) %*% qr_result_coefficient1
predict_quantile<- as.data.frame(predict_quantile)
colnames(predict_quantile) = c("PR10","PR20","PR30","PR40","Median","PR60","PR70"
,"PR80","PR90")
print(predict_quantile)
})
# output$qrplot <-  renderPlot({
#   x = regression_x[1,]
#   x[,2:20]=0
#   x[,23:78]=0
#   x["area"] = input$area
#   area2 = input$area^2
#   x["area_square"] = area2
#   if (input$section != "d20") {
#     x[input$section] = 1
#     x[paste0("area", input$section)]= input$area
#     x[paste0("area2", input$section)]= area2
#   }
#   if (input$kind != "d40") {
#     x[input$kind] = 1
#   }
#   if (!is.null(input$top)) {x[input$top] = 1}
#   if (input$kind != "d40"&input$section != "d20") {
#     x[paste0(input$kind,input$section)] = 1
#   }
#   source("distancevariable.R")
#   distance<-distance_output(input$address)
#   x["min_station"]<-distance$min_station
#   x["min_park"]<-distance$min_park
#   x=as.matrix(x)
#   regression_output(x)
# })
source("shinylatlngdistance.R",local = T)
# source("source_map.R",local = T)
})
output$distance<-renderTable({
address_df <- data.frame(lat = 0,lng = 0,loc_type=NA)
root = "http://maps.google.com/maps/api/geocode/"
return.call = "xml"
sensor = "false"
# address_df<-c()
url_gen = paste0(root, return.call, "?address=",input$address, "&sensor=", sensor)
html_code<-read_xml(url_gen)
if(xml_text(xml_find_first(html_code,"//GeocodeResponse//status"))=="OK"){
lat=xml_find_first(html_code,"//result//geometry//location//lat")%>%xml_text()
lng=xml_find_first(html_code,"//result//geometry//location//lng")%>%xml_text()
loc_type=xml_find_first(html_code,"//result//geometry//location_type")%>%xml_text()
address_df[1,1] <- lat
address_df[1,2] <- lng
address_df[1,3] <- loc_type
}else if(xml_text(xml_find_first(html_code,"//GeocodeResponse//status"))=="ZERO_RESULTS"){
lat= ""
lng= ""
loc_type=""
address_df[1] <- lat
address_df[2] <- lng
address_df[3] <- loc_type
}
# ===================算距離=============================
station_location<-read.table("station_location.csv",header = T,sep = ",",fileEncoding = "UTF-8",stringsAsFactors = F)
park<-read.table("park.csv",header = T,sep = ",",fileEncoding = "UTF-8",stringsAsFactors = F)
park_location <- park[,c(1,6,7)]
address_df$lat <- as.numeric(address_df$lat)
address_df$lng <- as.numeric(address_df$lng)
park_location$ParkName<-as.character(park_location$ParkName)
park_location$Latitude <- as.numeric(park_location$Latitude)
park_location$Longitude <- as.numeric(park_location$Longitude)
distance_of_station <- data.frame(min_station = rep(0,dim(address_df)[1]),
min_station_name = rep(0,dim(address_df)[1]),
min_park = rep(0,dim(address_df)[1]),
min_park_name = rep(0,dim(address_df)[1]))
for(i in 1:length(address_df$lat)){ ######你把起點跟終點改一下，可以繼續往下算最短距離。
if(is.na(address_df[i,1]) == T) next
temp <- rep(0,dim(station_location)[1])
for(j in 1:dim(station_location)[1]){
temp[j] <- distCosine(address_df[i,c(2,1)] , station_location[j,c(4,3)])
}
distance_of_station[i,1] <- min(temp)
################################################################################################
######### 超重要！這邊多寫一個邏輯判斷式，是因為相同最膽距離下，可能會同時存在兩個捷運站，
######### 例如，給定最短距離是500公尺，剛好第一筆資料跟忠孝復興捷運站跟中山國中站的距離都是500
######### 所以這這種情況下，我先把最短捷運站名稱定義成NA，之後再想辦法處理。刪除NA資料時，要避開
######### 此欄位，因為此欄位還是存在最短距離的自變數
################################################################################################
if(length(station_location[ temp == min(temp) ,2]) > 1){
distance_of_station[i,2] <-NA
}else{
distance_of_station[i,2] <- station_location[ temp == min(temp) ,2]
}
################################################################################################
temp <- rep(0,dim(park_location)[1])
for(j in 1:dim(park_location)[1]){
temp[j] <- distCosine(address_df[i,c(2,1)] , park_location[j,c(3,2)])
}
distance_of_station[i,3] <- min(temp)
###################################################################################################
#跟前面同理   #####################################################################################
if(length(park_location[ temp == min(temp) ,1]) > 1){
distance_of_station[i,4] <-NA
}else{
distance_of_station[i,4] <- park_location[ temp == min(temp) ,1]}
################################################################################################
print(i)
}
print(distance_of_station)
})
source('D://final_house_system/source_map_icon.R')
shiny::runApp()
library(leaflet)
install.packages("leaflet")
runApp()
install.packages("sandwich")
runApp()
install.packages("lmtest")
install.packages("quantreg")
runApp()
install.packages("tidyr")
runApp()
install.packages("httr")
runApp()
install.packages("RCurl")
runApp()
install.packages("XML")
install.packages("xml2")
install.packages("geospere")
install.packages("geosphere")
install.packages("rvest")
runApp()
runApp()
library(leaflet)
renderLeaflet
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
runApp()
source('D://final_house_system/source_map.R', encoding = 'UTF-8')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
